<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Bezier Interpolation - exported from Medium</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 20px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 18px;
      }
      </style></head><body><article>
<header>
<h1>Bezier Interpolation</h1>
</header>
<section data-field="subtitle">
It’s really not that hard.
</section>
<section data-field="body">
<section class=" section--bottomCenter section-image--coverFade is-imageBackgrounded is-backgrounded is-darkBackgrounded section--first"><div class="section-background"contenteditable="false" data-image-id="1*kTw2EXTYoP9rOkhVDEBvmg.jpeg" data-width="1400" data-height="1120"><div class="section-backgroundImage"style="background-image: url(https://d262ilb51hltx0.cloudfront.net/fit/t/2000/1600/gradv/29/81/55/1*kTw2EXTYoP9rOkhVDEBvmg.jpeg);"></div><br></div><div class="section-coverFadePadding u-ignoreBlock"><div class="section-content" data-scroll="cover-fade"><div class="section-inner layoutSingleColumn"><h2 name="title" class="graf--h2 graf--first"><a id="title"></a>Bezier Interpolation</h2><h4 name="subtitle" class="graf--h4 graf--last"><a id="subtitle"></a>It’s really not that hard.</h4></div></div></div><div class="section-captionContent u-ignoreBlock"></div></section><section name="0f98"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><p name="2675" class="graf--p graf--first"><a id="2675"></a>After becoming frustrated with Apple’s SpriteKit and it’s lack of features, I decided to go all out and implement the missing ones myself. One of these features Apple “forgot” to implement (or half-assedly implemented )was easing on their animations. When my needs eventually called for easing along a specific path, I was flat out of luck. Although easing in itself is relatively easy to implement when moving objects from A to B in a straight line, moving along a curve is another story entirely. So I set out to learn about bezier curves. It’s wasn’t a particularly fun task because most of the online resources were either to verbose or just showed unhelpful snippets of code with loads of tiny, unlabeled variables. Then, which should have been my first stop, I stumbled on <a target="_blank" href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" data-href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" class="markup--anchor markup--p-anchor" rel="nofollow">Bezier Curves on Wikipedia</a> and it all clicked when I hit this gif.</p><figure name="c604" class="graf--figure"><a id="c604"></a><div class="aspectRatioPlaceholder is-locked" style="max-width: 360px; max-height: 150px;"><div class="aspect-ratio-fill" style="padding-bottom: 41.699999999999996%;"></div><img class="graf-image" data-image-id="1*RdNctOG0RlAfzvrAez2rVQ.gif" data-width="360" data-height="150" src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*RdNctOG0RlAfzvrAez2rVQ.gif"></div><figcaption class="imageCaption">Bezier curve animation. Whoever makes these gifs, I love you.</figcaption></figure><p name="b60e" class="graf--p"><a id="b60e"></a>This is a cubic bezier curve. A cubic bezier curve is, in essence, four points. <em class="markup--em markup--p-em">Po </em>is the start point, <em class="markup--em markup--p-em">P1</em> and <em class="markup--em markup--p-em">P2</em> are control points 1 &amp; 2 and <em class="markup--em markup--p-em">P3</em> is the end point. The start and end point denote the beginning and end points of the path and the control points dictate how the path moves from the start to the finish. As you can see from the gif, the only variable changing is <em class="markup--em markup--p-em">t</em> which denotes how far the path has progressed from <em class="markup--em markup--p-em">P0</em> to <em class="markup--em markup--p-em">P3</em> (think percent).</p><p name="4260" class="graf--p"><a id="4260"></a>Take a look at how the green point moves along the line <em class="markup--em markup--p-em">P0</em> to <em class="markup--em markup--p-em">P1</em>. All it’s doing is moving from A to B, linearly, with T. To get this point at T on P0 to P1, we’ll create a function called <em class="markup--em markup--p-em">pointInLine. </em>This function takes in three parameters, point A the start of a line, point B the end of a line and percent T. It returns the point at T between A and B.</p><pre name="c257" class="graf--pre"><a id="c257"></a>CGPoint pointInLine(CGPoint A, CGPoint B, float T) {<br> CGPoint C;<br> C.x = A.x - ((A.x - B.x) * T);<br> C.y = A.y - ((A.y - B.y) * T);<br> return C;<br>}</pre><figure name="e3ba" class="graf--figure postField--insetLeftImage"><a id="e3ba"></a><div class="aspectRatioPlaceholder is-locked" style="max-width: 350px; max-height: 294px;"><div class="aspect-ratio-fill" style="padding-bottom: 83.89999999999999%;"></div><img class="graf-image" data-image-id="1*R2GfQ03RUHAaybNwnjJ-HQ.png" data-width="361" data-height="303" data-action="zoom" data-action-value="1*R2GfQ03RUHAaybNwnjJ-HQ.png" src="https://d262ilb51hltx0.cloudfront.net/max/1200/1*R2GfQ03RUHAaybNwnjJ-HQ.png"></div></figure><p name="192d" class="graf--p"><a id="192d"></a>The formula in this function is the same for each axis. It get’s the length of the line (on each axis respectively) by taking A - B and multiplies it by the percent T (between 0-1). It then adds the new, shortened line segment back onto the original point A to get a new point C. This function is the basis of all our calculations.</p><p name="2182" class="graf--p"><a id="2182"></a>Let’s take a look at our gif again, except freeze it on this specific frame stopped at <em class="markup--em markup--p-em">t = 50</em>.</p><figure name="3a32" class="graf--figure"><a id="3a32"></a><div class="aspectRatioPlaceholder is-locked" style="max-width: 360px; max-height: 150px;"><div class="aspect-ratio-fill" style="padding-bottom: 41.699999999999996%;"></div><img class="graf-image" data-image-id="1*sjqkXkKxHcA7pCavwXgX2g.png" data-width="360" data-height="150" src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*sjqkXkKxHcA7pCavwXgX2g.png"></div></figure><p name="91f5" class="graf--p"><a id="91f5"></a>I’ve marked where the algorithm is getting the points at <em class="markup--em markup--p-em">T = 50</em> on each line. <em class="markup--em markup--p-em">a </em>is on the line <em class="markup--em markup--p-em">p0-p1, b</em> is on the line <em class="markup--em markup--p-em">p1-p2</em>, <em class="markup--em markup--p-em">c</em> is on the line <em class="markup--em markup--p-em">p2-p3</em>. Let’s get <em class="markup--em markup--p-em">a, b </em>and<em class="markup--em markup--p-em"> c </em>using our <em class="markup--em markup--p-em">pointInLine</em> function from earlier at <em class="markup--em markup--p-em">T = 0.50.</em></p><pre name="f9ce" class="graf--pre"><a id="f9ce"></a>float T = 0.50;<br>CGPoint A = pointInLine(p0, p1, T);<br>CGPoint B = pointInLine(p1, p2, T);<br>CGPoint C = pointInLine(p2, p3, T);</pre><p name="7878" class="graf--p"><a id="7878"></a>Moving further, we get <em class="markup--em markup--p-em">d </em>and <em class="markup--em markup--p-em">e </em>using the same method as above with instead of <em class="markup--em markup--p-em">p0, p1, p2 </em>and<em class="markup--em markup--p-em"> p3</em>, we use <em class="markup--em markup--p-em">a, b </em>and <em class="markup--em markup--p-em">c.</em></p><figure name="d9d6" class="graf--figure"><a id="d9d6"></a><div class="aspectRatioPlaceholder is-locked" style="max-width: 360px; max-height: 150px;"><div class="aspect-ratio-fill" style="padding-bottom: 41.699999999999996%;"></div><img class="graf-image" data-image-id="1*5qOylkuinPYCEMWWYgcPxQ.png" data-width="360" data-height="150" src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*5qOylkuinPYCEMWWYgcPxQ.png"></div></figure><pre name="2d0a" class="graf--pre"><a id="2d0a"></a>float T = 0.5;<br>CGPoint A = pointInLine(p0, p1, T);<br>CGPoint B = pointInLine(p1, p2, T);<br>CGPoint C = pointInLine(p2, p3, T);<br>CGPoint D = pointInLine(A, B, T); // The new D<br>CGPoint E = pointInLine(B, C, T); // and E</pre><p name="7f9b" class="graf--p"><a id="7f9b"></a>Now were down to our last point, <em class="markup--em markup--p-em">f</em>, which is the actual point on the curve. The one were looking for.</p><figure name="d5ff" class="graf--figure"><a id="d5ff"></a><div class="aspectRatioPlaceholder is-locked" style="max-width: 360px; max-height: 150px;"><div class="aspect-ratio-fill" style="padding-bottom: 41.699999999999996%;"></div><img class="graf-image" data-image-id="1*8Kkf6KiQtmtwMcRmll6lPA.png" data-width="360" data-height="150" src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*8Kkf6KiQtmtwMcRmll6lPA.png"></div></figure><pre name="06b3" class="graf--pre"><a id="06b3"></a>float T = 0.5;<br>CGPoint A = pointInLine(p0, p1, T);<br>CGPoint B = pointInLine(p1, p2, T);<br>CGPoint C = pointInLine(p2, p3, T);<br>CGPoint D = pointInLine(A, B, T);<br>CGPoint E = pointInLine(B, C, T);<br>CGPoint F = pointInLine(D, E, T); // The juicy one</pre><p name="4568" class="graf--p"><a id="4568"></a>All that’s left now is to generate the curve of all points. Of course it’s not possible to generate <em class="markup--em markup--p-em">all</em> the points but what you can do is generate enough to generate a smooth curve.</p><pre name="f1b4" class="graf--pre"><a id="f1b4"></a>// Get 100 points<br>for(CGFloat T = 0; T &lt; 1; T += 0.01) {<br> CGPoint A = pointInLine(p0, p1, T);<br> CGPoint B = pointInLine(p1, p2, T);<br> CGPoint C = pointInLine(p2, p3, T);<br> CGPoint D = pointInLine(A, B, T);<br> CGPoint E = pointInLine(B, C, T);<br> CGPoint F = pointInLine(D, E, T);<br> drawPoint(F); // And draw the point on the screen<br>}</pre><p name="a3e6" class="graf--p"><a id="a3e6"></a>And there we go, a cubic bezier curve. What about quad curves, the 2nd degree bezier curve? Quad curves are simply half a bezier curve. Instead of 2 control points, we have one. A quad curve can be generated by drawing the change in position of percent T along line A-C.</p><pre name="1710" class="graf--pre"><a id="1710"></a>// We have 3 points<br>CGPoint p0, p1, p2;<br>CGPoint A = pointInLine(p0, p1, T);<br>CGPoint B = pointInLine(p1, p2, T);<br>CGPoint D = pointInLine(A, B, T); // The point in the quad curve</pre><p name="cdff" class="graf--p"><a id="cdff"></a>Notice anything interesting here? The exact code for generating a point on the quad curve exists in the cubic curve. Let’s break it up even further.</p><pre name="ea1e" class="graf--pre"><a id="ea1e"></a>CGPoint pointInQuadCurve(CGPoint p0, CGPoint p1, CGPoint p2) {<br> CGPoint A = pointInLine(p0, p1, T);<br> CGPoint B = pointInLine(p1, p2, T);<br> return pointInLine(A, B, T); // The point in the quad curve<br>}</pre><p name="87c8" class="graf--p"><a id="87c8"></a>Now use this in our cubic curve, since a cubic curve is made up of two quad curves.</p><pre name="652b" class="graf--pre"><a id="652b"></a>CGPoint pointInCubicCurve(CGPoint p0, CGPoint p1, <br>     CGPoint p2, CGPoint p3) {<br> CGPoint A = pointInQuadCurve(p0, p1, p2);<br> CGPoint B = pointInQuadCurve(p1, p2, p3);<br> return pointInLine(A, B, T);<br>}</pre><p name="f4af" class="graf--p"><a id="f4af"></a>How about a quintic curve?</p><pre name="dda6" class="graf--pre"><a id="dda6"></a>CGPoint pointInQuinticCurve(CGPoint p0, CGPoint p1, CGPoint p2,<br>     CGPoint p3, CGPoint p4) {<br> CGPoint A = pointInQuadCurve(p0, p1, p2, p3);<br> CGPoint B = pointInQuadCurve(p1, p2, p3, p4);<br> return pointInLine(A, B, T);<br>}</pre><p name="d286" class="graf--p graf--last"><a id="d286"></a>You should have noticed by now the recurring pattern in the curve generation. You use the nth-1 degree function twice and then find the point in the line at T to get the nth degree curve point. Quintic is probably the most you’ll ever need, if ever need it.</p></div></div></section><section name="2ad9" class=" section--last"><div class="section-divider layoutSingleColumn"><hr class="section-divider"></div><div class="section-content"><div class="section-inner layoutSingleColumn"><p name="2fe6" class="graf--p graf--first graf--last"><a id="2fe6"></a>Hope you enjoyed my fairly informal and (probably too) detailed introduction to bezier curves. Have fun drawing your curves! The above code is implemented in my <a target="_blank" href="http://github.com/adriancooney/SKMech" data-href="http://github.com/adriancooney/SKMech" class="markup--anchor markup--p-anchor" rel="nofollow">SKMech Spritekit utility library</a>, if you were wondering.</p></div></div></section>
</section>
<footer><p>Exported from <a href="https://medium.com">Medium</a> on January 4, 2015.</p><p><a href="https://medium.com/p/13b68563313a">View the original</a></p></footer></article>

</body></html>